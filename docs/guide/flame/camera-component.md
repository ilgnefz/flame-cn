---
prev:
  text: 摄像机和视口
  link: /guide/flame/camera-and-viewport.md
next:
  text: 输入
  link: /guide/flame/inputs/gesture-input.md
---

# 摄像机组件

::: tip 提示
本文档描述了一个新的实验性API。处理摄像机的更传统的方法在 [摄像机和视口](/guide/flame/camera-and-viewport.md)。
:::

摄像机作为组件是构建游戏的另一种方法，这种方法允许更灵活地放置摄像机，甚至同时拥有多个摄像机。

为了理解这种方法的工作原理，假设您的游戏世界是一个独立于您的应用程序而存在于某处的实体。 想象一下，您的游戏只是一个窗口，您可以通过它观察那个世界。 您可以随时关闭那个窗口，游戏世界仍然存在。 或者，相反，您可以打开多个同时查看同一个世界（或不同世界）的窗口。

有了这种心态，我们现在可以理解摄像机作为组件的工作原理。

首先是[World](#world)类，它包含游戏世界中的所有组件。`World `组件可以挂载在任何地方，例如在游戏类的根目录。

然后，一个“观察”世界的 [CameraComponent](#cameracomponent)类。内置`Viewport`和`Viewfinder`，可以灵活地在屏幕上的任何位置显示世界，还可以控制观看位置和角度。


## World

这个组件应该用于托管构成游戏世界的所有其他组件。World类的主要属性是它不通过传统的方式渲染，而是创建一个或多个[camerarcomponent](#cameracomponent)来查看世界。

游戏可以有多个`World`实例，可以在同一时间或不同时间进行渲染。例如，如果您有两个世界 A 和 B 和一个单一的摄像机，然后将摄像机的目标从 A 切换到 B，将立即切换到世界B的视图，而不需要卸载 A，然后挂载 B。


## CameraComponent

这是一个渲染`World`的组件。它需要在构造过程中引用一个`World`实例；然而，之后目标世界可以被另一个世界取代。多个摄像头可以同时观察同一个世界。

一个`CameraComponent`内部还有两个组件:一个[Viewport](#viewport)和一个[Viewfinder](#viewfinder)。与World对象不同，摄像机拥有视口和取景器，这意味着这些组件是摄像机的子组件。

还有一个静态属性 `CameraComponent.currentCamera`，它仅在渲染阶段不为空，并返回当前执行渲染的摄像机对象。这仅在某些高级用例中需要，在这些用例中，组件的呈现取决于摄像机设置。例如，一些组件可能决定跳过呈现自己和他们的子组件，如果他们在摄像机的视区之外。


## Viewport

`Viewport`是一个窗口，通过它可以看到`World`。该窗口在屏幕上具有一定的大小、形状和位置。有多种可用的视口，您可以始终实现自己的视口。

`Viewport`是一个组件，这意味着您可以向它添加其他组件。这些子组件将受视口位置的影响，但不受其剪辑蒙版的影响。因此，如果视口是进入游戏世界的窗口，那么它的子窗口就是您可以放在窗口顶部的东西。

向视口添加元素是实现 HUD 组件的一种方便方法。

以下视口可用：
  - `MaxViewport`：默认值。 这个视口会扩展到游戏所允许的最大尺寸，即它将等于游戏画布的大小。
  - `FixedSizeViewport`：具有预定义大小的简单矩形视口。
  - `FixedAspectRatioViewport`：一个可以扩展到游戏画布中的矩形视口，但保持其纵横比。`CircularViewport`：圆形的视口，大小固定。


## Viewfinder

摄像机的这一部分负责了解我们当前正在查看的底层游戏世界中的哪个位置。 `Viewfinder`还控制缩放级别和视口的旋转角度。

取景器（Viewfinder）的锚点属性允许您指定视口内的哪个点作为摄像机的逻辑中心。例如，在横向卷轴动作游戏中，镜头通常会聚焦在主角身上，而主角并不出现在屏幕中央，而是更靠近左下角的位置。这个偏离中心的位置将是摄像机的逻辑中心，由取景器的锚控制。

添加到取景器中的子组件将被渲染成世界的一部分（但在上面）。更有用的是在取景器中添加行为组件，例如[Effects](/guide/flame/effects.md)或其他控制器。


## 摄像机控制

有几种方法可以在运行时修改摄像机的设置：

1. 手动操作。您总是可以覆盖 `CameraComponent.update()`方法（或取景器或取景窗上的相同方法），并在其中根据您的需要改变取景器的位置或缩放。这种方法在某些情况下可能是可行的，但一般不推荐使用。
2. 对摄像机的`Viewfinder`或`Viewport`应用效果和/或行为。效果和行为是特殊类型的组件，其目的是随着时间的推移修改它们附加到的组件的某些属性。
3. 使用特殊的摄像机功能，如 `follow()`和 `moveTo()`。实际上，这种方法使用了与第(2)条中相同的效果/行为。

摄像头有几种方法来控制它的行为：

 - `Camera.follow()`：强制摄像机跟随提供的目标。您可以选择限制摄像机的最大移动速度，或者只允许它水平/垂直移动。
   
 - `Camera.stop()`：将撤消前一次调用的效果，并将摄像机停在当前位置。
   
 - `Camera.moveTo()`：可用于将摄像机移动到世界地图上的指定点。如果摄像机已经跟随另一个组件或者向另一个点移动，那么这些行为将被自动取消。
   
 - `Camera.setBounds()`：允许您添加限制摄像机允许去的地方。这些限制的形式是一个`Shape`，通常是一个矩形，但也可以是任何其他形状。

## 与传统Camera的比较

与普通 [Camera](camera_and_viewport.md)相比，`CameraComponent`有几个优点和缺点。

优点：
  - 多个摄像机可以同时添加到游戏中
  - 更灵活地选择位置和视口的大小
  - 将摄像机从一个世界切换到另一个世界可以瞬间发生，而不需要卸载一个世界然后安装另一个世界
  - 支持旋转的世界视图
  - (NYI) 效果可以应用于视口或取景器
  - (NYI)更灵活的摄像机控制器

缺点（我们计划在不久的将来消除这些缺点）：
  - 摄像机控制尚未实现
  - 事件传播可能并不总是正确工作
